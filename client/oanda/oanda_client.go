// Code generated by go-swagger; DO NOT EDIT.

package oanda

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new oanda API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for oanda API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
GetInstrumentsInstrumentOrderBook gets order book

Fetch a gzip compressed order book for an instrument.
*/
func (a *Client) GetInstrumentsInstrumentOrderBook(params *GetInstrumentsInstrumentOrderBookParams) (*GetInstrumentsInstrumentOrderBookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInstrumentsInstrumentOrderBookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetInstrumentsInstrumentOrderBook",
		Method:             "GET",
		PathPattern:        "/instruments/{instrument}/orderBook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInstrumentsInstrumentOrderBookReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetInstrumentsInstrumentOrderBookOK), nil

}

/*
GetInstrumentsInstrumentPositionBook gets position book

Fetch a gzip compressed position book for an instrument.
*/
func (a *Client) GetInstrumentsInstrumentPositionBook(params *GetInstrumentsInstrumentPositionBookParams) (*GetInstrumentsInstrumentPositionBookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInstrumentsInstrumentPositionBookParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetInstrumentsInstrumentPositionBook",
		Method:             "GET",
		PathPattern:        "/instruments/{instrument}/positionBook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInstrumentsInstrumentPositionBookReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetInstrumentsInstrumentPositionBookOK), nil

}

/*
CancelOrder cancels order

Cancel a pending Order in an Account
*/
func (a *Client) CancelOrder(params *CancelOrderParams) (*CancelOrderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelOrderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cancelOrder",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/orders/{orderSpecifier}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CancelOrderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CancelOrderOK), nil

}

/*
ClosePosition closes position

Closeout the open Position for a specific instrument in an Account.
*/
func (a *Client) ClosePosition(params *ClosePositionParams) (*ClosePositionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClosePositionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "closePosition",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/positions/{instrument}/close",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClosePositionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ClosePositionOK), nil

}

/*
CloseTrade closes trade

Close (partially or fully) a specific open Trade in an Account
*/
func (a *Client) CloseTrade(params *CloseTradeParams) (*CloseTradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloseTradeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "closeTrade",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/trades/{tradeSpecifier}/close",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloseTradeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloseTradeOK), nil

}

/*
ConfigureAccount configures account

Set the client-configurable portions of an Account.
*/
func (a *Client) ConfigureAccount(params *ConfigureAccountParams) (*ConfigureAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConfigureAccountParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "configureAccount",
		Method:             "PATCH",
		PathPattern:        "/accounts/{accountID}/configuration",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ConfigureAccountReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ConfigureAccountOK), nil

}

/*
CreateOrder creates order

Create an Order for an Account
*/
func (a *Client) CreateOrder(params *CreateOrderParams) (*CreateOrderCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateOrderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createOrder",
		Method:             "POST",
		PathPattern:        "/accounts/{accountID}/orders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateOrderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateOrderCreated), nil

}

/*
GetAccount accounts details

Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.
*/
func (a *Client) GetAccount(params *GetAccountParams) (*GetAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccountParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAccount",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAccountReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAccountOK), nil

}

/*
GetAccountChanges polls account updates

Endpoint used to poll an Account for its current state and changes since a specified TransactionID.
*/
func (a *Client) GetAccountChanges(params *GetAccountChangesParams) (*GetAccountChangesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccountChangesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAccountChanges",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/changes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAccountChangesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAccountChangesOK), nil

}

/*
GetAccountInstruments accounts instruments

Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.
*/
func (a *Client) GetAccountInstruments(params *GetAccountInstrumentsParams) (*GetAccountInstrumentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccountInstrumentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAccountInstruments",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/instruments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAccountInstrumentsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAccountInstrumentsOK), nil

}

/*
GetAccountSummary accounts summary

Get a summary for a single Account that a client has access to.
*/
func (a *Client) GetAccountSummary(params *GetAccountSummaryParams) (*GetAccountSummaryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccountSummaryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAccountSummary",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/summary",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAccountSummaryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAccountSummaryOK), nil

}

/*
GetExternalUserInfo externals user info

Fetch the externally-available user information for the specified user. This endpoint is intended to be used by 3rd parties that have been authorized by a user to view their personal information.
*/
func (a *Client) GetExternalUserInfo(params *GetExternalUserInfoParams) (*GetExternalUserInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetExternalUserInfoParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getExternalUserInfo",
		Method:             "GET",
		PathPattern:        "/users/{userSpecifier}/externalInfo",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetExternalUserInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetExternalUserInfoOK), nil

}

/*
GetInstrumentCandles gets candlesticks

Fetch candlestick data for an instrument.
*/
func (a *Client) GetInstrumentCandles(params *GetInstrumentCandlesParams) (*GetInstrumentCandlesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInstrumentCandlesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getInstrumentCandles",
		Method:             "GET",
		PathPattern:        "/instruments/{instrument}/candles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInstrumentCandlesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetInstrumentCandlesOK), nil

}

/*
GetOrder gets order

Get details for a single Order in an Account
*/
func (a *Client) GetOrder(params *GetOrderParams) (*GetOrderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOrderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOrder",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/orders/{orderSpecifier}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOrderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOrderOK), nil

}

/*
GetPosition instruments position

Get the details of a single Instrument's Position in an Account. The Position may by open or not.
*/
func (a *Client) GetPosition(params *GetPositionParams) (*GetPositionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPositionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPosition",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/positions/{instrument}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPositionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPositionOK), nil

}

/*
GetPrices currents account prices

Get pricing information for a specified list of Instruments within an Account.
*/
func (a *Client) GetPrices(params *GetPricesParams) (*GetPricesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPricesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPrices",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/pricing",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPricesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPricesOK), nil

}

/*
GetTrade trades details

Get the details of a specific Trade in an Account
*/
func (a *Client) GetTrade(params *GetTradeParams) (*GetTradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTradeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTrade",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/trades/{tradeSpecifier}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTradeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTradeOK), nil

}

/*
GetTransaction transactions details

Get the details of a single Account Transaction.
*/
func (a *Client) GetTransaction(params *GetTransactionParams) (*GetTransactionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTransactionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTransaction",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/transactions/{transactionID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTransactionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTransactionOK), nil

}

/*
GetTransactionRange transactions ID range

Get a range of Transactions for an Account based on the Transaction IDs.
*/
func (a *Client) GetTransactionRange(params *GetTransactionRangeParams) (*GetTransactionRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTransactionRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTransactionRange",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/transactions/idrange",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTransactionRangeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTransactionRangeOK), nil

}

/*
GetTransactionsSinceID transactions since ID

Get a range of Transactions for an Account starting at (but not including) a provided Transaction ID.
*/
func (a *Client) GetTransactionsSinceID(params *GetTransactionsSinceIDParams) (*GetTransactionsSinceIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTransactionsSinceIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTransactionsSinceId",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/transactions/sinceid",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTransactionsSinceIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTransactionsSinceIDOK), nil

}

/*
GetUserInfo users info

Fetch the user information for the specified user. This endpoint is intended to be used by the user themself to obtain their own information.
*/
func (a *Client) GetUserInfo(params *GetUserInfoParams) (*GetUserInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserInfoParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserInfo",
		Method:             "GET",
		PathPattern:        "/users/{userSpecifier}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUserInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserInfoOK), nil

}

/*
ListAccounts lists accounts

Get a list of all Accounts authorized for the provided token.
*/
func (a *Client) ListAccounts(params *ListAccountsParams) (*ListAccountsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAccountsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listAccounts",
		Method:             "GET",
		PathPattern:        "/accounts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAccountsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListAccountsOK), nil

}

/*
ListOpenPositions opens positions

List all open Positions for an Account. An open Position is a Position in an Account that currently has a Trade opened for it.
*/
func (a *Client) ListOpenPositions(params *ListOpenPositionsParams) (*ListOpenPositionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListOpenPositionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listOpenPositions",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/openPositions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListOpenPositionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListOpenPositionsOK), nil

}

/*
ListOpenTrades lists open trades

Get the list of open Trades for an Account
*/
func (a *Client) ListOpenTrades(params *ListOpenTradesParams) (*ListOpenTradesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListOpenTradesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listOpenTrades",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/openTrades",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListOpenTradesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListOpenTradesOK), nil

}

/*
ListOrders lists orders

Get a list of Orders for an Account
*/
func (a *Client) ListOrders(params *ListOrdersParams) (*ListOrdersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListOrdersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listOrders",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/orders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListOrdersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListOrdersOK), nil

}

/*
ListPendingOrders pendings orders

List all pending Orders in an Account
*/
func (a *Client) ListPendingOrders(params *ListPendingOrdersParams) (*ListPendingOrdersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListPendingOrdersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listPendingOrders",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/pendingOrders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListPendingOrdersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListPendingOrdersOK), nil

}

/*
ListPositions lists positions

List all Positions for an Account. The Positions returned are for every instrument that has had a position during the lifetime of an the Account.
*/
func (a *Client) ListPositions(params *ListPositionsParams) (*ListPositionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListPositionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listPositions",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/positions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListPositionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListPositionsOK), nil

}

/*
ListTrades lists trades

Get a list of Trades for an Account
*/
func (a *Client) ListTrades(params *ListTradesParams) (*ListTradesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListTradesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listTrades",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/trades",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListTradesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListTradesOK), nil

}

/*
ListTransactions lists transactions

Get a list of Transactions pages that satisfy a time-based Transaction query.
*/
func (a *Client) ListTransactions(params *ListTransactionsParams) (*ListTransactionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListTransactionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listTransactions",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/transactions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListTransactionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListTransactionsOK), nil

}

/*
ReplaceOrder replaces order

Replace an Order in an Account by simultaneously cancelling it and creating a replacement Order
*/
func (a *Client) ReplaceOrder(params *ReplaceOrderParams) (*ReplaceOrderCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceOrderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceOrder",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/orders/{orderSpecifier}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ReplaceOrderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ReplaceOrderCreated), nil

}

/*
SetOrderClientExtensions sets order extensions

Update the Client Extensions for an Order in an Account. Do not set, modify, or delete clientExtensions if your account is associated with MT4.
*/
func (a *Client) SetOrderClientExtensions(params *SetOrderClientExtensionsParams) (*SetOrderClientExtensionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetOrderClientExtensionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setOrderClientExtensions",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/orders/{orderSpecifier}/clientExtensions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetOrderClientExtensionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetOrderClientExtensionsOK), nil

}

/*
SetTradeClientExtensions sets trade client extensions

Update the Client Extensions for a Trade. Do not add, update, or delete the Client Extensions if your account is associated with MT4.
*/
func (a *Client) SetTradeClientExtensions(params *SetTradeClientExtensionsParams) (*SetTradeClientExtensionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetTradeClientExtensionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setTradeClientExtensions",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/trades/{tradeSpecifier}/clientExtensions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetTradeClientExtensionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetTradeClientExtensionsOK), nil

}

/*
SetTradeDependentOrders sets dependent orders

Create, replace and cancel a Trade's dependent Orders (Take Profit, Stop Loss and Trailing Stop Loss) through the Trade itself
*/
func (a *Client) SetTradeDependentOrders(params *SetTradeDependentOrdersParams) (*SetTradeDependentOrdersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetTradeDependentOrdersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setTradeDependentOrders",
		Method:             "PUT",
		PathPattern:        "/accounts/{accountID}/trades/{tradeSpecifier}/orders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetTradeDependentOrdersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetTradeDependentOrdersOK), nil

}

/*
StreamPricing prices stream

Get a stream of Account Prices starting from when the request is made.
This pricing stream does not include every single price created for the Account, but instead will provide at most 4 prices per second (every 250 milliseconds) for each instrument being requested.
If more than one price is created for an instrument during the 250 millisecond window, only the price in effect at the end of the window is sent. This means that during periods of rapid price movement, subscribers to this stream will not be sent every price.
Pricing windows for different connections to the price stream are not all aligned in the same way (i.e. they are not all aligned to the top of the second). This means that during periods of rapid price movement, different subscribers may observe different prices depending on their alignment.
*/
func (a *Client) StreamPricing(params *StreamPricingParams) (*StreamPricingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStreamPricingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "streamPricing",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/pricing/stream",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StreamPricingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*StreamPricingOK), nil

}

/*
StreamTransactions transactions stream

Get a stream of Transactions for an Account starting from when the request is made.
*/
func (a *Client) StreamTransactions(params *StreamTransactionsParams) (*StreamTransactionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStreamTransactionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "streamTransactions",
		Method:             "GET",
		PathPattern:        "/accounts/{accountID}/transactions/stream",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StreamTransactionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*StreamTransactionsOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
