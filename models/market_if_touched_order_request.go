// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MarketIfTouchedOrderRequest A MarketIfTouchedOrderRequest specifies the parameters that may be set when creating a Market-if-Touched Order.
// swagger:model MarketIfTouchedOrderRequest
type MarketIfTouchedOrderRequest struct {

	// client extensions
	ClientExtensions *ClientExtensions `json:"clientExtensions,omitempty"`

	// The date/time when the MarketIfTouched Order will be cancelled if its timeInForce is "GTD".
	GtdTime string `json:"gtdTime,omitempty"`

	// The MarketIfTouched Order's Instrument.
	Instrument string `json:"instrument,omitempty"`

	// Specification of how Positions in the Account are modified when the Order is filled.
	PositionFill string `json:"positionFill,omitempty"`

	// The price threshold specified for the MarketIfTouched Order. The MarketIfTouched Order will only be filled by a market price that crosses this price from the direction of the market price at the time when the Order was created (the initialMarketPrice). Depending on the value of the Order's price and initialMarketPrice, the MarketIfTouchedOrder will behave like a Limit or a Stop Order.
	Price string `json:"price,omitempty"`

	// The worst market price that may be used to fill this MarketIfTouched Order.
	PriceBound string `json:"priceBound,omitempty"`

	// stop loss on fill
	StopLossOnFill *StopLossDetails `json:"stopLossOnFill,omitempty"`

	// take profit on fill
	TakeProfitOnFill *TakeProfitDetails `json:"takeProfitOnFill,omitempty"`

	// The time-in-force requested for the MarketIfTouched Order. Restricted to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
	TimeInForce string `json:"timeInForce,omitempty"`

	// trade client extensions
	TradeClientExtensions *ClientExtensions `json:"tradeClientExtensions,omitempty"`

	// trailing stop loss on fill
	TrailingStopLossOnFill *TrailingStopLossDetails `json:"trailingStopLossOnFill,omitempty"`

	// Specification of what component of a price should be used for comparison when determining if the Order should be filled.
	TriggerCondition string `json:"triggerCondition,omitempty"`

	// The type of the Order to Create. Must be set to "MARKET_IF_TOUCHED" when creating a Market If Touched Order.
	Type string `json:"type,omitempty"`

	// The quantity requested to be filled by the MarketIfTouched Order. A posititive number of units results in a long Order, and a negative number of units results in a short Order.
	Units string `json:"units,omitempty"`
}

// Validate validates this market if touched order request
func (m *MarketIfTouchedOrderRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientExtensions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePositionFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStopLossOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTakeProfitOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeInForce(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTradeClientExtensions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTrailingStopLossOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTriggerCondition(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MarketIfTouchedOrderRequest) validateClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientExtensions) { // not required
		return nil
	}

	if m.ClientExtensions != nil {

		if err := m.ClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientExtensions")
			}
			return err
		}
	}

	return nil
}

var marketIfTouchedOrderRequestTypePositionFillPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OPEN_ONLY","REDUCE_FIRST","REDUCE_ONLY","DEFAULT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderRequestTypePositionFillPropEnum = append(marketIfTouchedOrderRequestTypePositionFillPropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderRequestPositionFillOPENONLY captures enum value "OPEN_ONLY"
	MarketIfTouchedOrderRequestPositionFillOPENONLY string = "OPEN_ONLY"
	// MarketIfTouchedOrderRequestPositionFillREDUCEFIRST captures enum value "REDUCE_FIRST"
	MarketIfTouchedOrderRequestPositionFillREDUCEFIRST string = "REDUCE_FIRST"
	// MarketIfTouchedOrderRequestPositionFillREDUCEONLY captures enum value "REDUCE_ONLY"
	MarketIfTouchedOrderRequestPositionFillREDUCEONLY string = "REDUCE_ONLY"
	// MarketIfTouchedOrderRequestPositionFillDEFAULT captures enum value "DEFAULT"
	MarketIfTouchedOrderRequestPositionFillDEFAULT string = "DEFAULT"
)

// prop value enum
func (m *MarketIfTouchedOrderRequest) validatePositionFillEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderRequestTypePositionFillPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrderRequest) validatePositionFill(formats strfmt.Registry) error {

	if swag.IsZero(m.PositionFill) { // not required
		return nil
	}

	// value enum
	if err := m.validatePositionFillEnum("positionFill", "body", m.PositionFill); err != nil {
		return err
	}

	return nil
}

func (m *MarketIfTouchedOrderRequest) validateStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.StopLossOnFill) { // not required
		return nil
	}

	if m.StopLossOnFill != nil {

		if err := m.StopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stopLossOnFill")
			}
			return err
		}
	}

	return nil
}

func (m *MarketIfTouchedOrderRequest) validateTakeProfitOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TakeProfitOnFill) { // not required
		return nil
	}

	if m.TakeProfitOnFill != nil {

		if err := m.TakeProfitOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("takeProfitOnFill")
			}
			return err
		}
	}

	return nil
}

var marketIfTouchedOrderRequestTypeTimeInForcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GTC","GTD","GFD","FOK","IOC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderRequestTypeTimeInForcePropEnum = append(marketIfTouchedOrderRequestTypeTimeInForcePropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderRequestTimeInForceGTC captures enum value "GTC"
	MarketIfTouchedOrderRequestTimeInForceGTC string = "GTC"
	// MarketIfTouchedOrderRequestTimeInForceGTD captures enum value "GTD"
	MarketIfTouchedOrderRequestTimeInForceGTD string = "GTD"
	// MarketIfTouchedOrderRequestTimeInForceGFD captures enum value "GFD"
	MarketIfTouchedOrderRequestTimeInForceGFD string = "GFD"
	// MarketIfTouchedOrderRequestTimeInForceFOK captures enum value "FOK"
	MarketIfTouchedOrderRequestTimeInForceFOK string = "FOK"
	// MarketIfTouchedOrderRequestTimeInForceIOC captures enum value "IOC"
	MarketIfTouchedOrderRequestTimeInForceIOC string = "IOC"
)

// prop value enum
func (m *MarketIfTouchedOrderRequest) validateTimeInForceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderRequestTypeTimeInForcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrderRequest) validateTimeInForce(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeInForce) { // not required
		return nil
	}

	// value enum
	if err := m.validateTimeInForceEnum("timeInForce", "body", m.TimeInForce); err != nil {
		return err
	}

	return nil
}

func (m *MarketIfTouchedOrderRequest) validateTradeClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.TradeClientExtensions) { // not required
		return nil
	}

	if m.TradeClientExtensions != nil {

		if err := m.TradeClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tradeClientExtensions")
			}
			return err
		}
	}

	return nil
}

func (m *MarketIfTouchedOrderRequest) validateTrailingStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TrailingStopLossOnFill) { // not required
		return nil
	}

	if m.TrailingStopLossOnFill != nil {

		if err := m.TrailingStopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("trailingStopLossOnFill")
			}
			return err
		}
	}

	return nil
}

var marketIfTouchedOrderRequestTypeTriggerConditionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEFAULT","INVERSE","BID","ASK","MID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderRequestTypeTriggerConditionPropEnum = append(marketIfTouchedOrderRequestTypeTriggerConditionPropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderRequestTriggerConditionDEFAULT captures enum value "DEFAULT"
	MarketIfTouchedOrderRequestTriggerConditionDEFAULT string = "DEFAULT"
	// MarketIfTouchedOrderRequestTriggerConditionINVERSE captures enum value "INVERSE"
	MarketIfTouchedOrderRequestTriggerConditionINVERSE string = "INVERSE"
	// MarketIfTouchedOrderRequestTriggerConditionBID captures enum value "BID"
	MarketIfTouchedOrderRequestTriggerConditionBID string = "BID"
	// MarketIfTouchedOrderRequestTriggerConditionASK captures enum value "ASK"
	MarketIfTouchedOrderRequestTriggerConditionASK string = "ASK"
	// MarketIfTouchedOrderRequestTriggerConditionMID captures enum value "MID"
	MarketIfTouchedOrderRequestTriggerConditionMID string = "MID"
)

// prop value enum
func (m *MarketIfTouchedOrderRequest) validateTriggerConditionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderRequestTypeTriggerConditionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrderRequest) validateTriggerCondition(formats strfmt.Registry) error {

	if swag.IsZero(m.TriggerCondition) { // not required
		return nil
	}

	// value enum
	if err := m.validateTriggerConditionEnum("triggerCondition", "body", m.TriggerCondition); err != nil {
		return err
	}

	return nil
}

var marketIfTouchedOrderRequestTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MARKET","LIMIT","STOP","MARKET_IF_TOUCHED","TAKE_PROFIT","STOP_LOSS","TRAILING_STOP_LOSS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderRequestTypeTypePropEnum = append(marketIfTouchedOrderRequestTypeTypePropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderRequestTypeMARKET captures enum value "MARKET"
	MarketIfTouchedOrderRequestTypeMARKET string = "MARKET"
	// MarketIfTouchedOrderRequestTypeLIMIT captures enum value "LIMIT"
	MarketIfTouchedOrderRequestTypeLIMIT string = "LIMIT"
	// MarketIfTouchedOrderRequestTypeSTOP captures enum value "STOP"
	MarketIfTouchedOrderRequestTypeSTOP string = "STOP"
	// MarketIfTouchedOrderRequestTypeMARKETIFTOUCHED captures enum value "MARKET_IF_TOUCHED"
	MarketIfTouchedOrderRequestTypeMARKETIFTOUCHED string = "MARKET_IF_TOUCHED"
	// MarketIfTouchedOrderRequestTypeTAKEPROFIT captures enum value "TAKE_PROFIT"
	MarketIfTouchedOrderRequestTypeTAKEPROFIT string = "TAKE_PROFIT"
	// MarketIfTouchedOrderRequestTypeSTOPLOSS captures enum value "STOP_LOSS"
	MarketIfTouchedOrderRequestTypeSTOPLOSS string = "STOP_LOSS"
	// MarketIfTouchedOrderRequestTypeTRAILINGSTOPLOSS captures enum value "TRAILING_STOP_LOSS"
	MarketIfTouchedOrderRequestTypeTRAILINGSTOPLOSS string = "TRAILING_STOP_LOSS"
)

// prop value enum
func (m *MarketIfTouchedOrderRequest) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderRequestTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrderRequest) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MarketIfTouchedOrderRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MarketIfTouchedOrderRequest) UnmarshalBinary(b []byte) error {
	var res MarketIfTouchedOrderRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
