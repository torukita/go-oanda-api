// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MarketIfTouchedOrder A MarketIfTouchedOrder is an order that is created with a price threshold, and will only be filled by a market price that is touches or crosses the threshold.
// swagger:model MarketIfTouchedOrder
type MarketIfTouchedOrder struct {

	// Date/time when the Order was cancelled (only provided when the state of the Order is CANCELLED)
	CancelledTime string `json:"cancelledTime,omitempty"`

	// ID of the Transaction that cancelled the Order (only provided when the Order's state is CANCELLED)
	CancellingTransactionID string `json:"cancellingTransactionID,omitempty"`

	// client extensions
	ClientExtensions *ClientExtensions `json:"clientExtensions,omitempty"`

	// The time when the Order was created.
	CreateTime string `json:"createTime,omitempty"`

	// Date/time when the Order was filled (only provided when the Order's state is FILLED)
	FilledTime string `json:"filledTime,omitempty"`

	// ID of the Transaction that filled this Order (only provided when the Order's state is FILLED)
	FillingTransactionID string `json:"fillingTransactionID,omitempty"`

	// The date/time when the MarketIfTouched Order will be cancelled if its timeInForce is "GTD".
	GtdTime string `json:"gtdTime,omitempty"`

	// The Order's identifier, unique within the Order's Account.
	ID string `json:"id,omitempty"`

	// The Market price at the time when the MarketIfTouched Order was created.
	InitialMarketPrice string `json:"initialMarketPrice,omitempty"`

	// The MarketIfTouched Order's Instrument.
	Instrument string `json:"instrument,omitempty"`

	// Specification of how Positions in the Account are modified when the Order is filled.
	PositionFill string `json:"positionFill,omitempty"`

	// The price threshold specified for the MarketIfTouched Order. The MarketIfTouched Order will only be filled by a market price that crosses this price from the direction of the market price at the time when the Order was created (the initialMarketPrice). Depending on the value of the Order's price and initialMarketPrice, the MarketIfTouchedOrder will behave like a Limit or a Stop Order.
	Price string `json:"price,omitempty"`

	// The worst market price that may be used to fill this MarketIfTouched Order.
	PriceBound string `json:"priceBound,omitempty"`

	// The ID of the Order that replaced this Order (only provided if this Order was cancelled as part of a cancel/replace).
	ReplacedByOrderID string `json:"replacedByOrderID,omitempty"`

	// The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).
	ReplacesOrderID string `json:"replacesOrderID,omitempty"`

	// The current state of the Order.
	State string `json:"state,omitempty"`

	// stop loss on fill
	StopLossOnFill *StopLossDetails `json:"stopLossOnFill,omitempty"`

	// take profit on fill
	TakeProfitOnFill *TakeProfitDetails `json:"takeProfitOnFill,omitempty"`

	// The time-in-force requested for the MarketIfTouched Order. Restricted to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
	TimeInForce string `json:"timeInForce,omitempty"`

	// trade client extensions
	TradeClientExtensions *ClientExtensions `json:"tradeClientExtensions,omitempty"`

	// Trade IDs of Trades closed when the Order was filled (only provided when the Order's state is FILLED and one or more Trades were closed as a result of the fill)
	TradeClosedIds []string `json:"tradeClosedIDs"`

	// Trade ID of Trade opened when the Order was filled (only provided when the Order's state is FILLED and a Trade was opened as a result of the fill)
	TradeOpenedID string `json:"tradeOpenedID,omitempty"`

	// Trade ID of Trade reduced when the Order was filled (only provided when the Order's state is FILLED and a Trade was reduced as a result of the fill)
	TradeReducedID string `json:"tradeReducedID,omitempty"`

	// trailing stop loss on fill
	TrailingStopLossOnFill *TrailingStopLossDetails `json:"trailingStopLossOnFill,omitempty"`

	// Specification of what component of a price should be used for comparison when determining if the Order should be filled.
	TriggerCondition string `json:"triggerCondition,omitempty"`

	// The type of the Order. Always set to "MARKET_IF_TOUCHED" for Market If Touched Orders.
	Type string `json:"type,omitempty"`

	// The quantity requested to be filled by the MarketIfTouched Order. A posititive number of units results in a long Order, and a negative number of units results in a short Order.
	Units string `json:"units,omitempty"`
}

// Validate validates this market if touched order
func (m *MarketIfTouchedOrder) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientExtensions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePositionFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStopLossOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTakeProfitOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeInForce(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTradeClientExtensions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTradeClosedIds(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTrailingStopLossOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTriggerCondition(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MarketIfTouchedOrder) validateClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientExtensions) { // not required
		return nil
	}

	if m.ClientExtensions != nil {

		if err := m.ClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientExtensions")
			}
			return err
		}
	}

	return nil
}

var marketIfTouchedOrderTypePositionFillPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OPEN_ONLY","REDUCE_FIRST","REDUCE_ONLY","DEFAULT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderTypePositionFillPropEnum = append(marketIfTouchedOrderTypePositionFillPropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderPositionFillOPENONLY captures enum value "OPEN_ONLY"
	MarketIfTouchedOrderPositionFillOPENONLY string = "OPEN_ONLY"
	// MarketIfTouchedOrderPositionFillREDUCEFIRST captures enum value "REDUCE_FIRST"
	MarketIfTouchedOrderPositionFillREDUCEFIRST string = "REDUCE_FIRST"
	// MarketIfTouchedOrderPositionFillREDUCEONLY captures enum value "REDUCE_ONLY"
	MarketIfTouchedOrderPositionFillREDUCEONLY string = "REDUCE_ONLY"
	// MarketIfTouchedOrderPositionFillDEFAULT captures enum value "DEFAULT"
	MarketIfTouchedOrderPositionFillDEFAULT string = "DEFAULT"
)

// prop value enum
func (m *MarketIfTouchedOrder) validatePositionFillEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderTypePositionFillPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrder) validatePositionFill(formats strfmt.Registry) error {

	if swag.IsZero(m.PositionFill) { // not required
		return nil
	}

	// value enum
	if err := m.validatePositionFillEnum("positionFill", "body", m.PositionFill); err != nil {
		return err
	}

	return nil
}

var marketIfTouchedOrderTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PENDING","FILLED","TRIGGERED","CANCELLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderTypeStatePropEnum = append(marketIfTouchedOrderTypeStatePropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderStatePENDING captures enum value "PENDING"
	MarketIfTouchedOrderStatePENDING string = "PENDING"
	// MarketIfTouchedOrderStateFILLED captures enum value "FILLED"
	MarketIfTouchedOrderStateFILLED string = "FILLED"
	// MarketIfTouchedOrderStateTRIGGERED captures enum value "TRIGGERED"
	MarketIfTouchedOrderStateTRIGGERED string = "TRIGGERED"
	// MarketIfTouchedOrderStateCANCELLED captures enum value "CANCELLED"
	MarketIfTouchedOrderStateCANCELLED string = "CANCELLED"
)

// prop value enum
func (m *MarketIfTouchedOrder) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrder) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MarketIfTouchedOrder) validateStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.StopLossOnFill) { // not required
		return nil
	}

	if m.StopLossOnFill != nil {

		if err := m.StopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stopLossOnFill")
			}
			return err
		}
	}

	return nil
}

func (m *MarketIfTouchedOrder) validateTakeProfitOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TakeProfitOnFill) { // not required
		return nil
	}

	if m.TakeProfitOnFill != nil {

		if err := m.TakeProfitOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("takeProfitOnFill")
			}
			return err
		}
	}

	return nil
}

var marketIfTouchedOrderTypeTimeInForcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GTC","GTD","GFD","FOK","IOC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderTypeTimeInForcePropEnum = append(marketIfTouchedOrderTypeTimeInForcePropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderTimeInForceGTC captures enum value "GTC"
	MarketIfTouchedOrderTimeInForceGTC string = "GTC"
	// MarketIfTouchedOrderTimeInForceGTD captures enum value "GTD"
	MarketIfTouchedOrderTimeInForceGTD string = "GTD"
	// MarketIfTouchedOrderTimeInForceGFD captures enum value "GFD"
	MarketIfTouchedOrderTimeInForceGFD string = "GFD"
	// MarketIfTouchedOrderTimeInForceFOK captures enum value "FOK"
	MarketIfTouchedOrderTimeInForceFOK string = "FOK"
	// MarketIfTouchedOrderTimeInForceIOC captures enum value "IOC"
	MarketIfTouchedOrderTimeInForceIOC string = "IOC"
)

// prop value enum
func (m *MarketIfTouchedOrder) validateTimeInForceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderTypeTimeInForcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrder) validateTimeInForce(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeInForce) { // not required
		return nil
	}

	// value enum
	if err := m.validateTimeInForceEnum("timeInForce", "body", m.TimeInForce); err != nil {
		return err
	}

	return nil
}

func (m *MarketIfTouchedOrder) validateTradeClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.TradeClientExtensions) { // not required
		return nil
	}

	if m.TradeClientExtensions != nil {

		if err := m.TradeClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tradeClientExtensions")
			}
			return err
		}
	}

	return nil
}

func (m *MarketIfTouchedOrder) validateTradeClosedIds(formats strfmt.Registry) error {

	if swag.IsZero(m.TradeClosedIds) { // not required
		return nil
	}

	return nil
}

func (m *MarketIfTouchedOrder) validateTrailingStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TrailingStopLossOnFill) { // not required
		return nil
	}

	if m.TrailingStopLossOnFill != nil {

		if err := m.TrailingStopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("trailingStopLossOnFill")
			}
			return err
		}
	}

	return nil
}

var marketIfTouchedOrderTypeTriggerConditionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEFAULT","INVERSE","BID","ASK","MID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderTypeTriggerConditionPropEnum = append(marketIfTouchedOrderTypeTriggerConditionPropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderTriggerConditionDEFAULT captures enum value "DEFAULT"
	MarketIfTouchedOrderTriggerConditionDEFAULT string = "DEFAULT"
	// MarketIfTouchedOrderTriggerConditionINVERSE captures enum value "INVERSE"
	MarketIfTouchedOrderTriggerConditionINVERSE string = "INVERSE"
	// MarketIfTouchedOrderTriggerConditionBID captures enum value "BID"
	MarketIfTouchedOrderTriggerConditionBID string = "BID"
	// MarketIfTouchedOrderTriggerConditionASK captures enum value "ASK"
	MarketIfTouchedOrderTriggerConditionASK string = "ASK"
	// MarketIfTouchedOrderTriggerConditionMID captures enum value "MID"
	MarketIfTouchedOrderTriggerConditionMID string = "MID"
)

// prop value enum
func (m *MarketIfTouchedOrder) validateTriggerConditionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderTypeTriggerConditionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrder) validateTriggerCondition(formats strfmt.Registry) error {

	if swag.IsZero(m.TriggerCondition) { // not required
		return nil
	}

	// value enum
	if err := m.validateTriggerConditionEnum("triggerCondition", "body", m.TriggerCondition); err != nil {
		return err
	}

	return nil
}

var marketIfTouchedOrderTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MARKET","LIMIT","STOP","MARKET_IF_TOUCHED","TAKE_PROFIT","STOP_LOSS","TRAILING_STOP_LOSS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketIfTouchedOrderTypeTypePropEnum = append(marketIfTouchedOrderTypeTypePropEnum, v)
	}
}

const (
	// MarketIfTouchedOrderTypeMARKET captures enum value "MARKET"
	MarketIfTouchedOrderTypeMARKET string = "MARKET"
	// MarketIfTouchedOrderTypeLIMIT captures enum value "LIMIT"
	MarketIfTouchedOrderTypeLIMIT string = "LIMIT"
	// MarketIfTouchedOrderTypeSTOP captures enum value "STOP"
	MarketIfTouchedOrderTypeSTOP string = "STOP"
	// MarketIfTouchedOrderTypeMARKETIFTOUCHED captures enum value "MARKET_IF_TOUCHED"
	MarketIfTouchedOrderTypeMARKETIFTOUCHED string = "MARKET_IF_TOUCHED"
	// MarketIfTouchedOrderTypeTAKEPROFIT captures enum value "TAKE_PROFIT"
	MarketIfTouchedOrderTypeTAKEPROFIT string = "TAKE_PROFIT"
	// MarketIfTouchedOrderTypeSTOPLOSS captures enum value "STOP_LOSS"
	MarketIfTouchedOrderTypeSTOPLOSS string = "STOP_LOSS"
	// MarketIfTouchedOrderTypeTRAILINGSTOPLOSS captures enum value "TRAILING_STOP_LOSS"
	MarketIfTouchedOrderTypeTRAILINGSTOPLOSS string = "TRAILING_STOP_LOSS"
)

// prop value enum
func (m *MarketIfTouchedOrder) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, marketIfTouchedOrderTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MarketIfTouchedOrder) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MarketIfTouchedOrder) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MarketIfTouchedOrder) UnmarshalBinary(b []byte) error {
	var res MarketIfTouchedOrder
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
