// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StopOrderRequest A StopOrderRequest specifies the parameters that may be set when creating a Stop Order.
// swagger:model StopOrderRequest
type StopOrderRequest struct {

	// client extensions
	ClientExtensions *ClientExtensions `json:"clientExtensions,omitempty"`

	// The date/time when the Stop Order will be cancelled if its timeInForce is "GTD".
	GtdTime string `json:"gtdTime,omitempty"`

	// The Stop Order's Instrument.
	Instrument string `json:"instrument,omitempty"`

	// Specification of how Positions in the Account are modified when the Order is filled.
	PositionFill string `json:"positionFill,omitempty"`

	// The price threshold specified for the Stop Order. The Stop Order will only be filled by a market price that is equal to or worse than this price.
	Price string `json:"price,omitempty"`

	// The worst market price that may be used to fill this Stop Order. If the market gaps and crosses through both the price and the priceBound, the Stop Order will be cancelled instead of being filled.
	PriceBound string `json:"priceBound,omitempty"`

	// stop loss on fill
	StopLossOnFill *StopLossDetails `json:"stopLossOnFill,omitempty"`

	// take profit on fill
	TakeProfitOnFill *TakeProfitDetails `json:"takeProfitOnFill,omitempty"`

	// The time-in-force requested for the Stop Order.
	TimeInForce string `json:"timeInForce,omitempty"`

	// trade client extensions
	TradeClientExtensions *ClientExtensions `json:"tradeClientExtensions,omitempty"`

	// trailing stop loss on fill
	TrailingStopLossOnFill *TrailingStopLossDetails `json:"trailingStopLossOnFill,omitempty"`

	// Specification of what component of a price should be used for comparison when determining if the Order should be filled.
	TriggerCondition string `json:"triggerCondition,omitempty"`

	// The type of the Order to Create. Must be set to "STOP" when creating a Stop Order.
	Type string `json:"type,omitempty"`

	// The quantity requested to be filled by the Stop Order. A posititive number of units results in a long Order, and a negative number of units results in a short Order.
	Units string `json:"units,omitempty"`
}

// Validate validates this stop order request
func (m *StopOrderRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientExtensions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePositionFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStopLossOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTakeProfitOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeInForce(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTradeClientExtensions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTrailingStopLossOnFill(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTriggerCondition(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StopOrderRequest) validateClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientExtensions) { // not required
		return nil
	}

	if m.ClientExtensions != nil {

		if err := m.ClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientExtensions")
			}
			return err
		}
	}

	return nil
}

var stopOrderRequestTypePositionFillPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OPEN_ONLY","REDUCE_FIRST","REDUCE_ONLY","DEFAULT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypePositionFillPropEnum = append(stopOrderRequestTypePositionFillPropEnum, v)
	}
}

const (
	// StopOrderRequestPositionFillOPENONLY captures enum value "OPEN_ONLY"
	StopOrderRequestPositionFillOPENONLY string = "OPEN_ONLY"
	// StopOrderRequestPositionFillREDUCEFIRST captures enum value "REDUCE_FIRST"
	StopOrderRequestPositionFillREDUCEFIRST string = "REDUCE_FIRST"
	// StopOrderRequestPositionFillREDUCEONLY captures enum value "REDUCE_ONLY"
	StopOrderRequestPositionFillREDUCEONLY string = "REDUCE_ONLY"
	// StopOrderRequestPositionFillDEFAULT captures enum value "DEFAULT"
	StopOrderRequestPositionFillDEFAULT string = "DEFAULT"
)

// prop value enum
func (m *StopOrderRequest) validatePositionFillEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypePositionFillPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validatePositionFill(formats strfmt.Registry) error {

	if swag.IsZero(m.PositionFill) { // not required
		return nil
	}

	// value enum
	if err := m.validatePositionFillEnum("positionFill", "body", m.PositionFill); err != nil {
		return err
	}

	return nil
}

func (m *StopOrderRequest) validateStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.StopLossOnFill) { // not required
		return nil
	}

	if m.StopLossOnFill != nil {

		if err := m.StopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stopLossOnFill")
			}
			return err
		}
	}

	return nil
}

func (m *StopOrderRequest) validateTakeProfitOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TakeProfitOnFill) { // not required
		return nil
	}

	if m.TakeProfitOnFill != nil {

		if err := m.TakeProfitOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("takeProfitOnFill")
			}
			return err
		}
	}

	return nil
}

var stopOrderRequestTypeTimeInForcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GTC","GTD","GFD","FOK","IOC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypeTimeInForcePropEnum = append(stopOrderRequestTypeTimeInForcePropEnum, v)
	}
}

const (
	// StopOrderRequestTimeInForceGTC captures enum value "GTC"
	StopOrderRequestTimeInForceGTC string = "GTC"
	// StopOrderRequestTimeInForceGTD captures enum value "GTD"
	StopOrderRequestTimeInForceGTD string = "GTD"
	// StopOrderRequestTimeInForceGFD captures enum value "GFD"
	StopOrderRequestTimeInForceGFD string = "GFD"
	// StopOrderRequestTimeInForceFOK captures enum value "FOK"
	StopOrderRequestTimeInForceFOK string = "FOK"
	// StopOrderRequestTimeInForceIOC captures enum value "IOC"
	StopOrderRequestTimeInForceIOC string = "IOC"
)

// prop value enum
func (m *StopOrderRequest) validateTimeInForceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypeTimeInForcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validateTimeInForce(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeInForce) { // not required
		return nil
	}

	// value enum
	if err := m.validateTimeInForceEnum("timeInForce", "body", m.TimeInForce); err != nil {
		return err
	}

	return nil
}

func (m *StopOrderRequest) validateTradeClientExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.TradeClientExtensions) { // not required
		return nil
	}

	if m.TradeClientExtensions != nil {

		if err := m.TradeClientExtensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tradeClientExtensions")
			}
			return err
		}
	}

	return nil
}

func (m *StopOrderRequest) validateTrailingStopLossOnFill(formats strfmt.Registry) error {

	if swag.IsZero(m.TrailingStopLossOnFill) { // not required
		return nil
	}

	if m.TrailingStopLossOnFill != nil {

		if err := m.TrailingStopLossOnFill.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("trailingStopLossOnFill")
			}
			return err
		}
	}

	return nil
}

var stopOrderRequestTypeTriggerConditionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEFAULT","INVERSE","BID","ASK","MID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypeTriggerConditionPropEnum = append(stopOrderRequestTypeTriggerConditionPropEnum, v)
	}
}

const (
	// StopOrderRequestTriggerConditionDEFAULT captures enum value "DEFAULT"
	StopOrderRequestTriggerConditionDEFAULT string = "DEFAULT"
	// StopOrderRequestTriggerConditionINVERSE captures enum value "INVERSE"
	StopOrderRequestTriggerConditionINVERSE string = "INVERSE"
	// StopOrderRequestTriggerConditionBID captures enum value "BID"
	StopOrderRequestTriggerConditionBID string = "BID"
	// StopOrderRequestTriggerConditionASK captures enum value "ASK"
	StopOrderRequestTriggerConditionASK string = "ASK"
	// StopOrderRequestTriggerConditionMID captures enum value "MID"
	StopOrderRequestTriggerConditionMID string = "MID"
)

// prop value enum
func (m *StopOrderRequest) validateTriggerConditionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypeTriggerConditionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validateTriggerCondition(formats strfmt.Registry) error {

	if swag.IsZero(m.TriggerCondition) { // not required
		return nil
	}

	// value enum
	if err := m.validateTriggerConditionEnum("triggerCondition", "body", m.TriggerCondition); err != nil {
		return err
	}

	return nil
}

var stopOrderRequestTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MARKET","LIMIT","STOP","MARKET_IF_TOUCHED","TAKE_PROFIT","STOP_LOSS","TRAILING_STOP_LOSS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		stopOrderRequestTypeTypePropEnum = append(stopOrderRequestTypeTypePropEnum, v)
	}
}

const (
	// StopOrderRequestTypeMARKET captures enum value "MARKET"
	StopOrderRequestTypeMARKET string = "MARKET"
	// StopOrderRequestTypeLIMIT captures enum value "LIMIT"
	StopOrderRequestTypeLIMIT string = "LIMIT"
	// StopOrderRequestTypeSTOP captures enum value "STOP"
	StopOrderRequestTypeSTOP string = "STOP"
	// StopOrderRequestTypeMARKETIFTOUCHED captures enum value "MARKET_IF_TOUCHED"
	StopOrderRequestTypeMARKETIFTOUCHED string = "MARKET_IF_TOUCHED"
	// StopOrderRequestTypeTAKEPROFIT captures enum value "TAKE_PROFIT"
	StopOrderRequestTypeTAKEPROFIT string = "TAKE_PROFIT"
	// StopOrderRequestTypeSTOPLOSS captures enum value "STOP_LOSS"
	StopOrderRequestTypeSTOPLOSS string = "STOP_LOSS"
	// StopOrderRequestTypeTRAILINGSTOPLOSS captures enum value "TRAILING_STOP_LOSS"
	StopOrderRequestTypeTRAILINGSTOPLOSS string = "TRAILING_STOP_LOSS"
)

// prop value enum
func (m *StopOrderRequest) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, stopOrderRequestTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StopOrderRequest) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StopOrderRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StopOrderRequest) UnmarshalBinary(b []byte) error {
	var res StopOrderRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
